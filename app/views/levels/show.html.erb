<div class="row-fluid">
  <div class="span11" id='game'>
  </div>
  <div class="span1">
    <p>
		  Level: <%= @level.id %>
    </p>
    <p>
		  Score: <span id='score'>0</span>
    </p>
    <p>
		  Keys: 0
    </p>
    <div id ='log'>
    </div>
  </div>
</div>

<script>

    var camera, scene, renderer, ball, ball_radius, keyboard, action_status, action_remaining, camera_offset;
	var player;
	var block_size;
	var highlight;
	var surface_highlight;
	var current_block;
	var current_surface;
	var debug = false;
	var viewport_x, viewport_y;

	// Used for rotating upwards
	var player_up_temp = null;
	var player_forward_temp = null;

    init();
	buildGeometry();
    animate();

    function init() {
		
		// Set up some global variables
		action_status = null;
		block_size = 1;
		ball_radius = block_size * 0.1;

		// Set up keyboard input
		keyboard = new THREEx.KeyboardState();

		// Create scene
		scene = new THREE.Scene();

		// Initialise viewport and renderer
		var viewport = $('#game');
		renderer = new THREE.WebGLRenderer();
		viewport_x = viewport.width();
		viewport_y = window.innerHeight - viewport.position().top - 20;
		renderer.setSize( viewport_x, viewport_y );
		viewport.append( renderer.domElement );

		// Initialise level data
		Level.addBlocks(<%= @level.blocks.to_json %>);
		Level.block_texture = "<%= @level.theme.texture_block %>";
		
    }

	function buildGeometry() {
		
		// Add player
		Player.addToScene(scene);

		// Skybox
		sky_material = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture("<%= @level.theme.texture_sky %>")});
		geometry = new THREE.SphereGeometry(18000, 16, 16);
		sky = new THREE.Mesh( geometry, sky_material );
		sky.scale.y = -1;
		scene.add( sky );

		// Blocks
		Level.addToScene(scene);

		// Initialise player coordinate frame position
		current_block = new THREE.Vector3(<%=@level.start[:position][0]%>, <%=@level.start[:position][1]%>, <%=@level.start[:position][2]%>)
		current_surface = 'T';
		Player.position.position = current_block.clone().multiplyScalar(block_size);

		// Debug info
		if (debug) {
	        geometry = new THREE.SphereGeometry(ball_radius*1.1, 16, 16);
	        material = new THREE.MeshBasicMaterial({wireframe: true, color: 0xFF0000});
			surface_highlight = new THREE.Mesh( geometry, material );
			scene.add( surface_highlight );
	        geometry = new THREE.CubeGeometry( block_size*1.01, block_size*1.01, block_size*1.01 );
	        material = new THREE.MeshBasicMaterial({wireframe: true});
			highlight = new THREE.Mesh( geometry, material );
			scene.add( highlight );
			Utility.update_debug_info();
		}
		
		// Add Entities
		<% @level.entities.each do |entity| %>			
			<%= entity[:object].mesh %>
		    scene.add(mesh);
			mesh.position = new THREE.Vector3(<%= entity[:position][0] %>, <%= entity[:position][1] %>+1, <%= entity[:position][2] %>);
		<% end %>

		// Ball
		texture = THREE.ImageUtils.loadTexture("<%= @level.theme.texture_ball %>")
		texture.minFilter = THREE.LinearFilter;
		texture.magFilter = THREE.NearestFilter;
		ball_material = new THREE.MeshBasicMaterial({map: texture});
		geometry = new THREE.SphereGeometry(ball_radius, 16, 16);
		ball = new THREE.Mesh( geometry, ball_material );
		ball.position.y = block_size/2 + ball_radius;
		Player.rotation.add( ball );
		
		// Position camera
        camera = new THREE.PerspectiveCamera( 75, viewport_x/viewport_y, 0.1, 20000 );
		camera.position = ball.position.clone().addSelf(Player.up.clone().multiplyScalar(ball_radius * 2.5)).addSelf(Player.forward.clone().multiplyScalar(ball_radius * -7));
		camera.lookAt( ball.position.clone().addSelf(Player.up.clone().multiplyScalar(ball_radius * 2)) );
        Player.rotation.add( camera );

	}

    function animate() {

        // note: three.js includes requestAnimationFrame shim
        requestAnimationFrame( animate );

		if (action_status == null) {
			// Detect keyboard presses unless an action is in progress
			if (keyboard.pressed("up")) {
				// Check if we are allowed to go forward
				if ( Level.isBlockAt(	current_block.clone().addSelf(Player.forward)) && 
 					!Level.isBlockAt(	current_block.clone().addSelf(Player.forward).addSelf(Player.up))) {
					action_status = "forward";
					action_left = 1.0;
				}
				else if ( Level.isBlockAt(current_block.clone().addSelf(Player.forward).addSelf(Player.up)) && 
						 !Level.isBlockAt(current_block.clone().addSelf(Player.forward).addSelf(Player.up).addSelf(Player.right)) && 
   						 !Level.isBlockAt(current_block.clone().addSelf(Player.forward).addSelf(Player.up).subSelf(Player.right))) {
					action_status = "change_plane_up";
					player_up_temp = Player.up.clone();
					player_forward_temp = Player.forward.clone();
					action_left = 1.0;
				}
				else if (!Level.isBlockAt(current_block.clone().addSelf(Player.forward).addSelf(Player.up)) && 
   						 !Level.isBlockAt(current_block.clone().addSelf(Player.forward)) && 
						 !Level.isBlockAt(current_block.clone().addSelf(Player.right)) && 
   						 !Level.isBlockAt(current_block.clone().subSelf(Player.right))) {
					action_status = "change_plane_down";
					action_left = 1.0;
				}
			}
			else if (keyboard.pressed("left")) {
				action_status = "turn_left";
				action_left = 1.0;
			}
			else if (keyboard.pressed("right")) {
				action_status = "turn_right";
				action_left = 1.0;
			}
			else if (keyboard.pressed("down")) {
				action_status = "turn_around";
				action_left = 1.0;
			}
			else if (keyboard.pressed("space")) {
				action_status = "jump";
				action_left = 1.0;
			}
			if (action_status && debug)
				log(action_status);
		}
		else {
			// Perform the action
			if (action_status == "forward") {
				Player.translate(Player.forward.clone().multiplyScalar(block_size*0.1));
				ball.rotation.x -= 0.2;
			}
			else if (action_status == "change_plane_up") {
				// Move player frame
				Player.translate(player_forward_temp.clone().addSelf(player_up_temp).multiplyScalar(block_size*0.1));
				// Rotate player frame
				angle = (Math.PI / 2.0) * 0.1;
				Player.rotate(Player.right, angle);
				// Roll
				ball.rotation.x -= 0.1;
			}
			else if (action_status == "change_plane_down") {
				// Rotate player frame
				angle = -(Math.PI / 2.0) * 0.1;
				Player.rotate(Player.right, angle);
				// Roll
				ball.rotation.x -= 0.2;
			}
			else if (action_status == "turn_left") {
				// Rotate player frame
				angle = (Math.PI / 2.0) * 0.1;
				Player.rotate(Player.up, angle);
			}
			else if (action_status == "turn_right") {
				// Rotate player frame
				angle = -(Math.PI / 2.0) * 0.1;
				Player.rotate(Player.up, angle);
			}
			else if (action_status == "turn_around") {
				// Rotate player frame
				angle = Math.PI * 0.1;
				Player.rotate(Player.up, angle);
			}
			else if (action_status == "jump") {
				ball.position.y += (block_size/2)*(action_left-0.55);
			} 
			action_left -= 0.1;
			if (action_left <= 0.1) {
				Utility.update_debug_info();
				// Round off vectors
				Utility.makeInteger(Player.right);
				Utility.makeInteger(Player.up);
				Utility.makeInteger(Player.forward);
				if (debug) {
					Utility.logVector("rght", Player.right);
					Utility.logVector("up", Player.up);
					Utility.logVector("fwd", Player.forward);
				}
				// clear action status
				action_status = null;
				action_left = 0;
			}
		}
		// Update current block
		previous_block = current_block.clone();
		current_block.x = Math.floor(Player.position.position.x + 0.5);
		current_block.y = Math.floor(Player.position.position.y + 0.5);
		current_block.z = Math.floor(Player.position.position.z + 0.5);

		// If block has changed
		if (current_block.x != previous_block.x || 
			current_block.y != previous_block.y ||
			current_block.z != previous_block.z) {
		    // Check for collisions
			<% @level.entities.each do |entity| %>			
				if (current_block.x == <%= entity[:position][0] %> && 
					current_block.y == <%= entity[:position][1] %> && 
					current_block.z == <%= entity[:position][2] %>) {
					<%= entity[:object].collide %>
				}
			<% end %>
		}
		
        Utility.render();

    }

</script>