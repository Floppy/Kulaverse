<div id='game'>
</div>
<script>

    var camera, scene, renderer, ball, ball_radius, keyboard, action_status, action_remaining, camera_offset;
	var player_x, player_y, player_z;

    init();
	buildGeometry();
    animate();

    function init() {
		
		action_status = null;
		ball_radius = 75;
		player_x = new THREE.Vector3(0,0,1);
		player_y = new THREE.Vector3(0,1,0);
		player_z = new THREE.Vector3(1,0,0);

		keyboard = new THREEx.KeyboardState();

        scene = new THREE.Scene();

		camera_offset = new THREE.Vector3(1000, -500, 0);

        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 20000 );
        scene.add( camera );

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
		
		var container = $('#game');
        container.append( renderer.domElement );

    }

	function buildGeometry() {
		
		// Skybox
		sky_material = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture("/assets/clouds.jpg")});
		geometry = new THREE.SphereGeometry(18000, 16, 16);
		sky = new THREE.Mesh( geometry, sky_material );
		sky.scale.y = -1;
		scene.add( sky );

		// Blocks
		block_size = 200;
        geometry = new THREE.CubeGeometry( block_size, block_size, block_size );
        block_material = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture("/assets/block.png")});
		<%= @level.blocks.each do |block_data| %>
			mesh = new THREE.Mesh( geometry, [block_material,block_material,block_material,block_material,block_material,block_material] );
			mesh.position.x = <%= block_data[0] %> * block_size;
			mesh.position.y = <%= block_data[1] %> * block_size;
			mesh.position.z = <%= block_data[2] %> * block_size;
			scene.add( mesh );
		<% end %>

		ball_material = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture("/assets/ball.png")});
		geometry = new THREE.SphereGeometry(ball_radius, 16, 16);
		ball = new THREE.Mesh( geometry, ball_material );
		ball.position.x = <%=@level.start[:position][0]%> * block_size;
		ball.position.y = (<%=@level.start[:position][1]%> * block_size) + block_size/2 + ball_radius;
		ball.position.z = <%=@level.start[:position][2]%> * block_size;
		scene.add( ball );

	}

    function animate() {

        // note: three.js includes requestAnimationFrame shim
        requestAnimationFrame( animate );

		if (action_status == null) {
			// Detect keyboard presses unless an action is in progress
			if (keyboard.pressed("up")) {
				action_status = "forward";
				action_left = 1.0;
			}
			else if (keyboard.pressed("left")) {
				action_status = "turn_left";
				action_left = 1.0;
			}
			else if (keyboard.pressed("right")) {
				action_status = "turn_right";
				action_left = 1.0;
			}
			else if (keyboard.pressed("down")) {
				action_status = "turn_around";
				action_left = 1.0;
			}
			else if (keyboard.pressed("space")) {
				action_status = "jump";
				action_left = 1.0;
			}
		}
		else {
			// Perform the action
			if (action_status == "forward") {
				ball.position.addSelf(player_z.clone().multiplyScalar(200*0.1));
				ball.rotation.z -= 0.2;
			}
			else if (action_status == "turn_left") {
				angle = (Math.PI / 2.0) * 0.1;
				r = new THREE.Matrix4();
				r.identity();
				r.setRotationAxis(player_y, angle);
				player_x = r.multiplyVector3(player_x);
				player_z = r.multiplyVector3(player_z);
			}
			else if (action_status == "turn_right") {
				angle = (Math.PI / 2.0) * 0.1;
				r = new THREE.Matrix4();
				r.identity();
				r.setRotationAxis(player_y, -angle);
				player_x = r.multiplyVector3(player_x);
				player_z = r.multiplyVector3(player_z);
			}
			else if (action_status == "turn_around") {
				angle = (Math.PI) * 0.1;
				r = new THREE.Matrix4();
				r.identity();
				r.setRotationAxis(player_y, angle);
				player_x = r.multiplyVector3(player_x);
				player_z = r.multiplyVector3(player_z);
			}
			else if (action_status == "jump") {
				ball.position.addSelf(player_y.clone().multiplyScalar(100*(action_left-0.55)));
			}
			action_left -= 0.1;
			if (action_left <= 0.1) {
				action_left = 0;
				action_status = null;
			}
		}

        render();

    }

    function render() {
		
		// Set camera position
		camera.position = ball.position.clone();		
		cam_offset_z = player_z.clone().multiplyScalar(-1000);
		cam_offset_y = player_y.clone().multiplyScalar(500);
		camera.position.addSelf(cam_offset_z).addSelf(cam_offset_y);
		camera.lookAt( ball.position );
		// Render scene
        renderer.render( scene, camera );

    }

</script>