<div id='game'>
</div>
<script>

    var camera, scene, renderer, ball, ball_radius, keyboard, action_status, action_remaining, camera_offset;
	var player_x, player_y, player_z;
	var player;
	var block_size;
	var highlight;
	var surface_highlight;
	var current_block;
	var current_surface;
	var debug = true;
	var block_list = {};

    init();
	buildGeometry();
    animate();

    function init() {
		
		action_status = null;
		
		block_size = 1;
		ball_radius = block_size * 0.375;

		player_x = new THREE.Vector3(0,0,1);
		player_y = new THREE.Vector3(0,1,0);
		player_z = new THREE.Vector3(1,0,0);

		keyboard = new THREEx.KeyboardState();

        scene = new THREE.Scene();

		player = new THREE.Object3D();
		scene.add(player);

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
		
		var container = $('#game');
        container.append( renderer.domElement );

		// Create block list
		<% @level.blocks.each do |block| %>
			block_list["<%= block[0] %>:<%= block[1] %>:<%= block[2] %>"] = [<%= block[0] %>, <%= block[1] %>, <%= block[2] %>];
		<% end %>

    }

	function buildGeometry() {
		
		// Skybox
		sky_material = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture("<%= @level.theme.texture_sky %>")});
		geometry = new THREE.SphereGeometry(18000, 16, 16);
		sky = new THREE.Mesh( geometry, sky_material );
		sky.scale.y = -1;
		scene.add( sky );

		// Blocks
		geometry = new THREE.CubeGeometry( block_size, block_size, block_size );
		block_material = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture("<%= @level.theme.texture_block %>")});
		for (var block in block_list) {
			mesh = new THREE.Mesh( geometry, [block_material,block_material,block_material,block_material,block_material,block_material] );
			mesh.position.x = block_list[block][0] * block_size;
			mesh.position.y = block_list[block][1] * block_size;
			mesh.position.z = block_list[block][2] * block_size;
			scene.add( mesh );
		}

		// Initialise player coordinate frame position
		current_block = new THREE.Vector3(<%=@level.start[:position][0]%>, <%=@level.start[:position][1]%>, <%=@level.start[:position][2]%>)
		current_surface = 'T';
		player.position = current_block.clone().multiplyScalar(block_size);
		player.rotation.y = Math.PI/2;

		// Debug info
		if (debug) {
	        geometry = new THREE.CubeGeometry( block_size*1.01, block_size*0.1, block_size*1.01 );
	        material = new THREE.MeshBasicMaterial({wireframe: true, color: 0xFF0000});
			surface_highlight = new THREE.Mesh( geometry, material );
			scene.add( surface_highlight );
	        geometry = new THREE.CubeGeometry( block_size*1.01, block_size*1.01, block_size*1.01 );
	        material = new THREE.MeshBasicMaterial({wireframe: true});
			highlight = new THREE.Mesh( geometry, material );
			scene.add( highlight );
			update_debug_info();
		}
		
		// Add Exit
		<%= @level.finish[:object].mesh %>
	    scene.add(mesh);
		mesh.position = new THREE.Vector3(<%= @level.finish[:position][0] %>, <%= @level.finish[:position][1] %>+1, <%= @level.finish[:position][2] %>);

		// Ball
		ball_material = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture("<%= @level.theme.texture_ball %>")});
		geometry = new THREE.SphereGeometry(ball_radius, 16, 16);
		ball = new THREE.Mesh( geometry, ball_material );
		ball.position.y = block_size/2 + ball_radius;
		player.add( ball );
		
		// Position camera
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 20000 );
		camera.position.z = -block_size * 5;
		camera.position.y = block_size * 2.5;
		camera.lookAt( ball.position );
        player.add( camera );

	}

	function isBlockAt(x,y,z) {
		return block_list[x+":"+y+":"+z];
	}
	
	function makeInteger(vector) {
		vector.x = Math.floor(vector.x+0.5);
		vector.y = Math.floor(vector.y+0.5);
		vector.z = Math.floor(vector.z+0.5);
	}

    function animate() {

        // note: three.js includes requestAnimationFrame shim
        requestAnimationFrame( animate );

		if (action_status == null) {
			// Detect keyboard presses unless an action is in progress
			if (keyboard.pressed("up")) {
				// Check if we are allowed to go forward
				if ( isBlockAt(	current_block.x + player_z.x, 
								current_block.y + player_z.y, 
								current_block.z + player_z.z) && 
 					!isBlockAt(	current_block.x + player_z.x + player_y.x, 
								current_block.y + player_z.y + player_y.y, 
								current_block.z + player_z.z + player_y.z)) {
					action_status = "forward";
					action_left = 1.0;
				}
				else if ( isBlockAt(current_block.x + player_z.x + player_y.x, 
									current_block.y + player_z.y + player_y.y, 
									current_block.z + player_z.z + player_y.z) && 
						 !isBlockAt(current_block.x + player_z.x + player_y.x + player_x.x,
							 		current_block.y + player_z.y + player_y.y + player_x.y,
									current_block.z + player_z.z + player_y.z + player_x.z) && 
   						 !isBlockAt(current_block.x + player_z.x + player_y.x - player_x.x,
   							 		current_block.y + player_z.y + player_y.y - player_x.y,
   									current_block.z + player_z.z + player_y.z - player_x.z)) {
					console.log("change_plane_up");
				}
				else if (!isBlockAt(current_block.x + player_z.x + player_y.x, 
									current_block.y + player_z.y + player_y.y, 
									current_block.z + player_z.z + player_y.z) && 
						 !isBlockAt(current_block.x + player_x.x,
							 		current_block.y + player_x.y,
									current_block.z + player_x.z) && 
   						 !isBlockAt(current_block.x - player_x.x,
   							 		current_block.y - player_x.y,
   									current_block.z - player_x.z)) {
					console.log("change_plane_down");
				}
			}
			else if (keyboard.pressed("left")) {
				action_status = "turn_left";
				action_left = 1.0;
			}
			else if (keyboard.pressed("right")) {
				action_status = "turn_right";
				action_left = 1.0;
			}
			else if (keyboard.pressed("down")) {
				action_status = "turn_around";
				action_left = 1.0;
			}
			else if (keyboard.pressed("space")) {
				action_status = "jump";
				action_left = 1.0;
			}
		}
		else {
			// Perform the action
			if (action_status == "forward") {
				player.position.addSelf(player_z.clone().multiplyScalar(block_size*0.1));
				ball.rotation.x += 0.2;
			}
			else if (action_status == "turn_left") {
				angle = (Math.PI / 2.0) * 0.1;
				r = new THREE.Matrix4();
				r.identity();
				r.setRotationAxis(player_y, angle);
				player_x = r.multiplyVector3(player_x);
				player_z = r.multiplyVector3(player_z);
				player.rotation.y += angle;
			}
			else if (action_status == "turn_right") {
				angle = (Math.PI / 2.0) * 0.1;
				r = new THREE.Matrix4();
				r.identity();
				r.setRotationAxis(player_y, -angle);
				player_x = r.multiplyVector3(player_x);
				player_z = r.multiplyVector3(player_z);
				player.rotation.y -= angle;
			}
			else if (action_status == "turn_around") {
				angle = (Math.PI) * 0.1;
				r = new THREE.Matrix4();
				r.identity();
				r.setRotationAxis(player_y, angle);
				player_x = r.multiplyVector3(player_x);
				player_z = r.multiplyVector3(player_z);
				player.rotation.y -= angle;
			}
			else if (action_status == "jump") {
				ball.position.addSelf(player_y.clone().multiplyScalar((block_size/2)*(action_left-0.55)));
			} 
			action_left -= 0.1;
			if (action_left <= 0.1) {
				action_left = 0;
				action_status = null;
				makeInteger(player_x);
				makeInteger(player_y);
				makeInteger(player_z);
			}
		}
		// Update current block
		previous_block = current_block.clone();
		current_block.x = Math.floor(player.position.x + 0.5);
		current_block.y = Math.floor(player.position.y + 0.5);
		current_block.z = Math.floor(player.position.z + 0.5);
		update_debug_info();

		// If block has changed
		if (current_block.x != previous_block.x || 
			current_block.y != previous_block.y ||
			current_block.z != previous_block.z) {
		    // Check for collisions
			if (current_block.x == <%= @level.finish[:position][0] %> && 
				current_block.y == <%= @level.finish[:position][1] %> && 
				current_block.z == <%= @level.finish[:position][2] %>) {
				<%= @level.finish[:object].collide %>
			}
		}
		
        render();

    }

	function update_debug_info()
	{
		if (!debug)
			return;
		// Update highlight
		highlight.position = current_block;
		surface_highlight.position = current_block.clone();
		switch (current_surface) {
			case 'T':
				surface_highlight.position.y += ((block_size/2)+0.05);
				break;
			case 'B':
				surface_highlight.position.y -= ((block_size/2)+0.05);
				break;
			case 'L':
				surface_highlight.position.x -= ((block_size/2)-0.05);
				surface_highlight.rotation.z = Math.PI;
				break;
			case 'R':
				surface_highlight.position.x += ((block_size/2)-0.05);
				surface_highlight.rotation.z = Math.PI;
				break;
			case 'N':
				surface_highlight.position.z += ((block_size/2)-0.05);
				surface_highlight.rotation.x = Math.PI;
				break;
			case 'F':
				surface_highlight.position.z -= ((block_size/2)-0.05);
				surface_highlight.rotation.x = Math.PI;
				break;
		}
	}

    function render() {
		
		// Render scene
        renderer.render( scene, camera );

    }

</script>